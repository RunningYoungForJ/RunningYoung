# JVM内存管理模型

> JVM内存管理即是管理运行时数据区

- 运行时数据区分类：
  - 所有线程共享：
    - 方法区
    - 堆
  - 线程隔离：
    - 虚拟机栈
    - 本地方法栈
    - 程序计数器


### 线程共享
#### 堆
> 堆是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域。在虚拟机启动时创建，唯一目的是用于存放对象实例。

1. 所有的对象实例以及数组都分配在堆上。
2. 堆是GC管理的主要区域，因此从垃圾回收的角度考虑，目前多采用分代收集算法，Java堆还可以细分为新生代和老生代。
3. 在JVM规范中，堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。在JVM配置中使用Xmx和Xms配置。
  1. Xmx：设置JVM最大堆内存空间。
  2. Xms：设置JVM初始堆内存空间。（可与Xmx相同，这样堆不可扩展，避免GC回收后进行调整）
4. 堆无法继续扩展时，会抛出OutOfMemmoryError异常。


#### 方法区
> 方法区是各个线程共享的内存区域，它们用于存储已被虚拟机加载的Class的相关信息：类信息（类名、访问修饰符、常量池等）、常量、静态变量、即时编译器编译后的代码等数据。

1. GC在方法区的回收目标主要是针对常量池的回收和针对类型的卸载。
2. 当方法区无法满足内存分配需求时，将抛出OutOfMemmoryErrori 异常。
3. 在JVM中使用MaxPermSize设置方法区大小。


##### 运行时常量池
> 运行时常量池是方法区的一部分，常量池主要存放Class文件中编译期生成的各种字面量和符号引用。这部分内容在类加载后存放到方法区的运行时常量池中。

1. 运行时常量池具有动态性，Java语言不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中，例如String的intern()方法。
2. 常量池无法申请到内存时抛出OutOfMemmoryError异常。


###线程隔离
#### 程序计数器
> 是一块较小的内存空间。作用是用于标识当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来获取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复都是依赖这个计数器完成。

1.  JVM中多线程通过**时间片轮转**的方式轮流切换线程。因此在任意确定时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个**独立的程序计数器**。各条线程之间的计数器互不影响，独立存储。
2.  如果线程正在执行一个Java方法，则这个计数器的值是正在执行的虚拟机字节码指令的地址；如果是一个**Native方法，则这个计数器值为空**。
3.  程序计数器是JVM中**唯一一个**没有规定任何OutOfMemmoryError情况的区域。


#### Java虚拟机栈
> Java虚拟机栈也是线程私有的，它的生命周期与线程相同。描述了**Java方法执行**的内存模型：每一个方法执行的时候都会同时创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息。每一个方法从调用到执行完成对应着虚拟机栈中栈帧入栈出栈的过程。
> ![Alt text](./1507802869344.png)
1. 局部变量表存放了编译期可知的各种基本数据类型、对象引用和返回地址类型。其中64位的long和double会占用2个局部变量空间，其余的数据类型占用1个空间。局部变量表所需的内存空间大小在编译期完成确定和分配，在方法运行期间，不会改变局部变量表的大小。
2. 方法存储在运行时常量池中，每一个栈帧都有一个动态链接指向该栈帧所属方法在运行时常量池中的地址。
3. 在JVM中，虚拟机栈有两个异常：
  1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
  2. 如果虚拟机栈在动态扩展时无法申请到足够的内从会抛出OutOfMemmoryError异常。
4. 在JVM中使用Xss配置虚拟机栈大小。


#### 本地方法栈
> 本地方法栈存储Native方法的内存模型，基本与Java虚拟机栈类似，也会抛出StackOverflowError异常和OutOfMemmoryError异常。


### 总结
1. 除了程序计数器以外，堆、方法区、栈、本地方法区都会产生OutOfMemmory异常（OOM）。
2. 堆的OOM：堆用于存储对象实例，产生OOM，只需要不断创建对象，并保证GC Root到对象之间具有可达路径。
3. ​


### 内存中对象访问
> 最简单的对象访问，也涉及栈、堆、方法区这三个最重要内存区域之间的关联。

```java
Object obj =new Object();
```
分析：
1. Object obj这部分的语义会反映到Java栈的本地变量表中，作为一个reference类型数据出现。
2. new Object()这部分语义会反映在Java堆中，形成一块存储了Object类型所有实例数据值（对象中各个实例字段的数据）的结构化内存。此外在Java堆中还包含能查找到此对象类型数据（对象类型、父类、实现的接口）的地址信息，这些都**存储在方法区**中。
> reference类型：一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问Java堆中的对象的具体位置。目前主流的访问方式有两种：句柄和直接指针。
> 1. 句柄：Java堆中会划分一块内存作为句柄池，reference中存储的就是对象在句柄池中的句柄地址，而该句柄地址对应的句柄中包含了对象实例数据和类型数据各自的具体地址信息。
> 2. 直接指针：reference中直接存储的就是对象在Java堆中的地址。但采用这种方式，必须要考虑如何放置访问类型数据的相关信息，因此在对象的结构化内存中，还需要包含一个指向该实例对象类型数据的指针引用。
> 3. 两种方式比较：句柄访问方式的最大好处是reference中存储的是稳定的句柄地址，在对象移动（GC回收）时只会改变句柄中的实例数据指针，而reference本身不需要改变；使用直接访问的最大好处是速度快，节省了一次指针定位的时间开销。